<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hash World</title>
  <style>
    /* Add any additional styles you need */
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.0/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/16/Stats.min.js"></script>
  
  <div class="start-screen" id="start-screen">
    <h1>Welcome to Hash World</h1>
    <p>Build your world and have fun!</p>
    <button class="start-button" onclick="startGame()">Start Game</button>
  </div>
  <br><br><br>
  <div><center><button id="connectButton">Connect Web3</button></center></div>
  <center><div id="account"></div></center>

  <script>
    const contractAddress = '0xcD6a42782d230D7c13A74ddec5dD140e55499Df9'; // Contract address
    const contractABI = [
      {
        "constant": true,
        "inputs": [],
        "name": "currentHash",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "deposit",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [],
        "name": "externalAccount",
        "outputs": [{"internalType": "address payable", "name": "", "type": "address"}],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [{"internalType": "address payable", "name": "newExternalAccount", "type": "address"}],
        "name": "updateExternalAccount",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "anonymous": false,
        "inputs": [{"indexed": true, "internalType": "address", "name": "sender", "type": "address"},
                   {"indexed": false, "internalType": "uint256", "name": "hash", "type": "uint256"}],
        "name": "HashGenerated",
        "type": "event"
      },
      {
        "stateMutability": "payable",
        "type": "receive"
      }
    ];

    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const contract = new ethers.Contract(contractAddress, contractABI, provider);
    let hashBalance = 1000000; // Starting HASH balance
    let inventory = []; // User's inventory
    let selectedBrick = null; // Selected brick
    let floatingBrick = null; // Brick floating above the ground
    let placedBricks = []; // Store placed bricks

    window.addEventListener('DOMContentLoaded', () => {
      const connectButton = document.getElementById('connectButton');
      const accountDiv = document.getElementById('account');

      // Check if MetaMask is installed
      if (typeof window.ethereum === 'undefined') {
        accountDiv.innerHTML = 'MetaMask is not installed. Please install MetaMask to interact with the dApp.';
        connectButton.disabled = true;
        return;
      }

      // Function to handle wallet connection
      const connectWallet = async () => {
        try {
          const accounts = await provider.send("eth_requestAccounts", []);
          accountDiv.innerHTML = `Connected Account: ${accounts[0]}`;
          connectButton.innerHTML = 'Wallet Connected';
          connectButton.disabled = true;
        } catch (error) {
          console.error('Error connecting to wallet:', error);
          accountDiv.innerHTML = 'Failed to connect wallet.';
        }
      };

      connectButton.addEventListener('click', connectWallet);
    });

    // Listen to HashGenerated event
    contract.on('HashGenerated', (sender, hash) => {
      console.log(`New HASH generated: ${hash} from ${sender}`);
      // Update UI with the new hash (if needed)
    });

    // Scene Setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.6); // Soft ambient light
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 10, 5).normalize();
    scene.add(directionalLight);

    const textureLoader = new THREE.CubeTextureLoader();
    const skybox = textureLoader.load([
      'https://example.com/skybox/px.jpg',
      'https://example.com/skybox/nx.jpg',
      'https://example.com/skybox/py.jpg',
      'https://example.com/skybox/ny.jpg',
      'https://example.com/skybox/pz.jpg',
      'https://example.com/skybox/nz.jpg'
    ]);
    scene.background = skybox;

    // Create the ground with realistic texture
    const groundTexture = new THREE.TextureLoader().load('https://example.com/ground_texture.jpg');
    const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
    const groundMaterial = new THREE.MeshPhongMaterial({ map: groundTexture });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Create Grid Helper
    const gridHelper = new THREE.GridHelper(100, 20);
    gridHelper.position.y = 0.01;
    scene.add(gridHelper);

    // Handle mouse movement (for raycasting)
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isTouching = false;

    window.addEventListener('mousemove', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    });

    function updateFloatingBrick() {
      if (floatingBrick) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(ground);
        if (intersects.length > 0) {
          let position = intersects[0].point;
          let maxHeight = 0;

          placedBricks.forEach(brick => {
            if (Math.abs(brick.position.x - position.x) < 1 && Math.abs(brick.position.z - position.z) < 1) {
              maxHeight = Math.max(maxHeight, brick.position.y);
            }
          });

          position.y = maxHeight + 0.5;
          floatingBrick.position.set(Math.floor(position.x), position.y, Math.floor(position.z));
        }
      }
    }

    // Define brick types with icons (use base64-encoded images or placeholders)
    const brickTypes = [
      { name: "Standard", size: [1, 0.5, 1], color: 0x0077ff, cost: 10, icon: "https://via.placeholder.com/40/0077ff/ffffff?text=1" },
      { name: "Large", size: [2, 1, 2], color: 0xff0000, cost: 25, icon: "https://via.placeholder.com/40/ff0000/ffffff?text=2" },
      { name: "Small", size: [0.5, 0.25, 0.5], color: 0x00ff00, cost: 5, icon: "https://via.placeholder.com/40/00ff00/ffffff?text=3" },
      { name: "Special", size: [1, 0.5, 1], color: 0xffff00, cost: 50, icon: "https://via.placeholder.com/40/ffff00/ffffff?text=4" }
    ];

    // Function to create a brick mesh with more realistic material
    function createBrick(type) {
      const geometry = new THREE.BoxGeometry(...brickTypes[type].size);
      const material = new THREE.MeshStandardMaterial({ color: brickTypes[type].color, roughness: 0.6, metalness: 0.1 });
      const brick = new THREE.Mesh(geometry, material);
      return brick;
    }

    // Camera setup with OrbitControls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    camera.position.set(5, 5, 5);
    camera.lookAt(0, 0, 0);

    // Animation Loop
    function animate() {
      requestAnimationFrame(animate);
      updateFloatingBrick();
      controls.update();
      renderer.render(scene, camera);
    }

    // Start the animation loop
    animate();

    // Start the game
    function startGame() {
      document.getElementById('start-screen').style.transition = "opacity 1s ease-in-out";
      document.getElementById('start-screen').style.opacity = 0;
      setTimeout(function () {
        document.getElementById('start-screen').style.display = 'none';
      }, 1000);
    }

    // Resize handling
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
